#include "Precompiled.h"
#include "..\Server\Server.h"
#include "..\Proxy\Hen.h"

using namespace Microsoft::WRL;

// Note:
// Method 1: Registration based COM activation
// In the command prompt, type the following to register the Server.dll component:
// C:\regsvr32 Server.dll
// To unregister:
// C:\ regsvr32 /u Server.dll

// implementing remotable client interfaces
struct EventHandler : RuntimeClass<RuntimeClassFlags<ClassicCom>,
                                   IAsyncHenEventHandler>
{
    HRESULT __stdcall OnCluck() override
    {
        TRACE(L"OnCluck\n");
        return S_OK;
    }
};

int main()
{
    // Replacing with IClassFactory
#if 0
    ComRuntime runtime;

    ComPtr<IHatchery> hatchery;

    HR(CoGetClassObject(__uuidof(Hen),
        CLSCTX_INPROC_SERVER,
        nullptr,
        __uuidof(hatchery),
        reinterpret_cast<void **>(hatchery.GetAddressOf())));

    ComPtr<IHen> hen;

    HR(hatchery->CreateHen(hen.GetAddressOf()));

    hen->Cluck();
#endif // 0

    // Using IClassFactory
#if 0
    ComRuntime runtime;

    ComPtr<IClassFactory> hatchery;

    HR(CoGetClassObject(__uuidof(Hen),
        CLSCTX_INPROC_SERVER,
        nullptr,
        __uuidof(hatchery),
        reinterpret_cast<void **>(hatchery.GetAddressOf())));

    ComPtr<IHen> hen;

    HR(hatchery->CreateInstance(nullptr,
        __uuidof(hen),
        reinterpret_cast<void **>(hen.GetAddressOf())));

    hen->Cluck();
#endif // 0

    // using simplier method:
    // calling CoCreateInstance() method instead of CreateInstance

#if 0
    ComRuntime runtime(Apartment::MultiThreaded);

    ComPtr<IHen> hen;

    HR(CoCreateInstance(__uuidof(Hen),
                        nullptr,
                        CLSCTX_INPROC_SERVER,
                        __uuidof(hen),
                        reinterpret_cast<void **>(hen.GetAddressOf())));

    hen->Cluck();

    // unloading the DLL from the client side
    for (;;)
    {
        CoFreeUnusedLibrariesEx(1000,0); // 1000 ms delay ; 2nd parameter is reserved
        hen.Reset();
        Sleep(1000);
    }
#endif // 0

#if 0
    // demo: using remote interfacing using header file generated by midl compiler
    ComRuntime runtime(Apartment::MultiThreaded);

    ComPtr<IPSFactoryBuffer> psFactory;

    HR(CoGetClassObject(__uuidof(IAsyncHenEventHandler),
                        CLSCTX_INPROC_SERVER,
                        nullptr,
                        __uuidof(psFactory),
                        reinterpret_cast<void **>(psFactory.GetAddressOf())));

    ComPtr<IHen> hen;

    HR(CoCreateInstance(__uuidof(Hen),
                        nullptr,
                        CLSCTX_INPROC_SERVER,
                        __uuidof(hen),
                        reinterpret_cast<void **>(hen.GetAddressOf())));

    hen->Cluck();
#endif // 0


#if 0
    // demo: local interfaces and proxies
    ComRuntime runtime(Apartment::MultiThreaded);

    ComPtr<IUnknown> hen;

    HR(CoCreateInstance(__uuidof(Hen),
        nullptr, // outer
        CLSCTX_INPROC_SERVER,
        __uuidof(hen),
        reinterpret_cast<void **>(hen.GetAddressOf())));

    ComPtr<IHen> local;

    if (S_OK == hen.CopyTo(local.GetAddressOf()))
    {
        local->Cluck();
    }
#endif // 0

    // implementing remotable client interfaces
    ComRuntime runtime(Apartment::SingleThreaded);

    // checking the apartment type
    APTTYPE type;
    APTTYPEQUALIFIER qualifier;
    HR(CoGetApartmentType(&type,&qualifier));

    ComPtr<IUnknown> hen;

    HR(CoCreateInstance(__uuidof(Hen),
                        nullptr,
                        CLSCTX_INPROC_SERVER,
                        __uuidof(hen),
                        reinterpret_cast<void **>(hen.GetAddressOf())));

    ComPtr<IHen> local;

    if (S_OK == hen.CopyTo(local.GetAddressOf()))
    {
        local->Cluck();
    }

    ComPtr<IAsyncHen> async;

    if (S_OK == hen.CopyTo(async.GetAddressOf()))
    {
        auto handler = Make<EventHandler>();

        HR(async->SetEventHandler(handler.Get()));
    }

    MSG message;

    while (BOOL result = GetMessage(&message, 0, 0, 0))
    {
        if(-1 != result) DispatchMessage(&message);
    }
}